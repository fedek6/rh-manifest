# Essential TypeScript bookmarks

## JS

- Basic architecture of to-do app — from page 7.
- Building interactive console tools — from page 20.
- Basic types & coercion — from page 43.
- `nodemon` usage — from page 41.
- Arrays — from page 54.
- Array functions — page 55.
- Spread operator — page 56.
- Spread & Rest operator on objects — page 59.
- Getters & setters — page 61.
- This keyword — page 64.
- Object prototypes and inheritance — page 74.
- Custom prototypes — page 78.
- Constructor functions — page 78.
- Defining Static Properties and Methods — page 82.
- Using JS classes — page 83.
- Class inheritance — page 84.
- Static methods — page 85.
- Iterators — page 86.
- Generators — page 88.
- Iterable objects — page 89.
- JS Collections — page 91.
- Object based collection — page 91.
- Map based collection — page 92.
- Collection based on unique symbols — page 94.
- Storing data by index (Sets) — page 95.
- JS modules — page 96.

## TS compiler

- Understanding TS config files — page 108.
- Version targeting / versions — page 116.
- Table of lib settings for compiler — page 118.
- Selecting a module format — page 120.
- Useful compiler settings — page 124.
- Testing and debugging — page 128.
- Unit testing — page 137.
- Jest in Node with TS — page 138.

## Type annotations

- Using any — page 155.
- Type unions — page 157.
- Type assertions — page 159.
- Type guard — page 162.
- Unknown type — page 164.
- Nullable types — page 166.
- Not null assertion (!) — page 169.
- Removing null from a Union with a Type Guard — page 170.

## Functions

- Using functions “quick reference” — page 173.
- Optional parameters — page 178.
- Rest parameter — page 180.
- Type annotations in function results — page 185.
- Overloading function types — page 187.

## Data types

- Arrays — page 191.
- Tuples — page 196.
- Enums — page 199.
- Constant Enums (faster ones) — page 205.
- Using literal value types — page 207.
- Mixing types in literals — page 209.
- Overrides with literals — page 210.
- Using type aliases — page 213.

## Objects

- Object shape type annotations — page 216.
- Methods in shape types (including optional methods) — page 218.
- Dealing with excess properties (`suppressExcessPropertyErrors` option) — page 221.
- Shape type unions — page 223.
- Using type guards for objects (using properties and `in` operator) — page 225.
- Type predicated functions — page 228.
- Type guarding with a type predicate function (object prediction helpers) — page 228.
- Type intersections — page 229.
- Intersections for data correlation (merging two objects using `id` etc.) — page 231.
- Merging properties with the same type (intersection merging) — page 234.
- Merging properties with different types (and the solution to an impossible types) — page 237.
- Method merging — page 238.


## Classes and interfaces

- Using classes — page 245.
- Using access control keywords — page 247.
- Uninitialized properties protection — page 249.
- Read-only properties — page 250.
- Simplified constructors — page 251.
- Inheritance — page 252.
- Understanding type inference for subclasses (avoiding type errors) — page 254.
- Abstract classes — page 255.
- Type guarding abstract classes — page 257.
- Interfaces — page 258.
- Implementing multiple interfaces — page 260.
- Extending interfaces — page 262.
- Shapes and interfaces — page 263.
- Optional interface properties and methods — page 264.
- Abstract interface implementation — page 266.
- Type guarding an interface — page 267.
- Dynamically creating properties (index signature) — page 279.

## Generic types

- Understating the problem — page 274.
- Constraining generic types (allow typed properties usage, narrow possible generic types) — page 279.
- Constraining generic types using shapes — page 280.
- Multiple type parameters — page 282.
- Applying a type parameter to a method — page 283.
- Extending features of the existing type parameters — page 286.
- Fixing generic type parameter — page 288.
- Restricting the Generic Type Parameter — page 288.
- Type guarding generic types (type predicate functions) — page 291.
- Static methods in a generic classes — page 292.
- Generic interfaces — page 294.
- Extending generic type interfaces — page 295.
- Implementing a Generic Interface — page 296.
- Restricting / fixing generic type parameter — page 297.
- Creating abstract interface implementations (this is cool) — page 297.

## Advanced generic types

- Generic collections (map & set) — page 303.
- Using generic iterators — page 305.
- Combination of iterable and iterator — page 307.
- Creating an iterable class — page 308.
- Using index type query (this is important) — page 309.
- Using the indexed access operator (creating a union of all type` types aka lookup types) also dynamic typing of returned function value — page 311.
- Using an index type of collection class — page 313.
- Type mapping (it's like looping through types) — page 315.
- Using generics in type mapping — page 316.
- Changing properties and mutability — page 317.
- Built-in type mappings — page 318.
- Mapping Specific Properties — page 319.
- Combining Transformations in a Single Mapping (chaining) — page 320.
- Creating types with a type mapping — page 320.
- Conditional types (ternary operator in types) — page 321.
- Nested conditional types (or how not to do it) — page 323.
- Conditional types in generic classes — page 323.
- Using Conditional Types with Type Unions (filtering out array of objects using `instanceof`) — page 325.
- Using the Built-in Distributive Conditional Types — page 326.
- Using Conditional Types in Type Mappings (or how to type a JS type converter) — page 326.
- Identifying Properties of a Specific Type (or how to filter out specific type from an array of objects) — page 327.
- Inferring Additional Types in Conditions (`infer` word, it might be used to flatten arrays of objects etc.) — page 329.
- Inferring types of functions — page 331.
- There are built-in conditional types (with inference) [building functional object factories] — page 331.

## Working with JS

- Useful options for compiler — page 334.
- Using `@ts-check` and `@ts-nocheck` — page 341.  
- Using comments to provide types (JSDoc) — page 343.  
- Using type declaration files — page 344.
- Describing NPM JS modules (or how to create local typings folder structure) — page 347.
- Definitely typed delcarations — page 350.
- Generating declaration files — page 354.


This book can be bought [here](https://www.apress.com/gp/book/9781484270103).

**Notice**: I use book` page numbers, not PDF ones.
